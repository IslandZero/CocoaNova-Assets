require 'digest'

module Nova::Helper::ObjCDSL

    SYSTEM_LIBS = {
        foundation: "Foundation/Foundation.h",
        uikit: "UIKit/UIKit.h"
    }

    # Basic

    def raw(content = "")
        @str ||= ""
        content += "\n"
        @str += content
        content
    end

    # Language Switching

    def mode(mode)
        @mode = mode
    end

    def objc
        mode :objc
        yield if block_given?
        @str
    end

    def objc?
        @mode == nil or @mode == :objc
    end

    # Metadata

    def created_at(*time)
        @created_at = Date.parse(time.join('-'))
    end

    def hash(data)
        raise "Hash something" if data == nil
        @hash = Digest::MD5.hexdigest data.to_s
    end

    # Comments

    def file_header(project=nil, user=nil, copyright=nil)
        if @created_at == nil
            created_at DateTime.now
        end
        if @hash == nil
            hash data
        end
        raw "//
//  #{File.basename(filename)}
//  #{project || "Nova"}
//
//  Created by #{user || "Nova" } on #{@created_at.strftime("%Y/%-m/%-d")}.
//  Copyright (c) #{@created_at.strftime("%Y")}å¹´ #{copyright || user || "Nova"}. All rights reserved.
//
//  Hash: #{@hash}
//
//  WARNNING: Generated by Nova, Donnot edit this file directly.\n"
    end

    def comment(content=nil)
        raw "// #{content}"
    end

    # Macros

    def import(*libs)
        libs.flatten.each do |lib|
            if SYSTEM_LIBS[lib.to_sym]
                lib = SYSTEM_LIBS[lib.to_sym]
                raw "#import <#{lib}>"
            else
                if lib.kind_of? String
                    if lib.to_s.index(".h")
                        raw "#import \"#{lib}\""
                    else
                        raw "#import \"#{lib}/#{lib}.h\""
                    end
                else
                    if lib.kind_of? Symbol
                        if lib.to_s.index(".h")
                            raw "#import <#{lib}>"
                        else
                            raw "#import <#{lib}/#{lib}.h>"
                        end
                    else
                        raise "WTF you passed for import ? #{lib}"
                    end
                end
            end
        end
        raw
    end

    def define(type, content)
        raw "#define #{type}  #{content}"
    end

    def define_str(type, content)
        define type, "@\"#{content}\""
    end

    # Type

    def typedef(src, des)
        raw "typedef #{src} #{des};"
    end

    # Structure / Enum

    def enum(name, values, options = {})
        base = options[:base] || "NSInteger"
        raw "typedef NS_ENUM(#{base}, #{name}) {"
        if options[:bitmask]
            raw "  #{name}None = 0,"
            if values.kind_of? Hash
                values.keys.each_with_index do |val, idx|
                    comment values[val].to_s
                    raw "  #{name}#{val} = 1 << #{idx},"
                end
            else
                values.each_with_index do |val, idx|
                    raw "  #{name}#{val} = 1 << #{idx},"
                end
            end
            raw "  #{name}All = 0b#{"1" * (values.count + 1)}"
        else
            if values.kind_of? Hash
                values.keys.each_with_index do |val, idx|
                    comment values[val].to_s
                    raw "  #{name}#{val},"
                end
            else
                values.each do |val|
                    raw "  #{name}#{val},"
                end
            end
        end
        raw "};"
    end

    # interface

    def _class(name)
        raw "@class #{name};"
    end

    def protocol(name, superclass = nil)
        super_str = if superclass then "<#{superclass}>" else "" end
        raw "@protocol #{name}#{super_str}"
        yield if block_given?
        raw "@end"
    end

    def interface(name, superclass = "NSObject", protocols = [])
        ptc = if protocols.empty? then "" else "<#{protocols.join(',')}>" end
        raw "@interface #{name}#{ptc} : #{superclass}"
        yield if block_given?
        raw "@end"
    end

    def property(name, type, options = {})
        atomic_str = options[:atomic] ? "atomic" : "nonatomic"
        policy_str = options[:policy] || :strong
        star_str   = (policy_str.to_s == "assign") ? "" : "*"
        raw "@property (#{atomic_str}, #{policy_str}) #{type} #{star_str} #{name};"
    end

    def implement(name)
        raw "@implementation #{name}"
        yield if block_given?
        raw "@end"
    end

    def class_method(*options)
        options = options.flatten
        raise "Method options.count < 2" unless options.count > 1
        return_type = options.shift
        start = "+ (#{return_type})"
        if options.length == 1
            start += "#{options[0]}"
        else
            raise "Not valid method signature" unless options.count % 3 == 0
            options.permutation(3) do |a,b,c|
                start += "#{a}:(#{b})#{c} "
            end
        end
        if block_given?
            start += "{"
            raw start
            yield
            raw "}"
        else
            start += ";"
            raw start
        end
    end

    def method(*options)
        options = options.flatten
        raise "Method options.count < 2" unless options.count > 1
        return_type = options.shift
        start = "- (#{return_type})"
        if options.length == 1
            start += "#{options[0]}"
        else
            raise "Not valid method signature" unless options.count % 3 == 0
            options.permutation(3) do |a,b,c|
                start += "#{a}:(#{b})#{c} "
            end
        end
        if block_given?
            start += "{\n"
            raw start
            yield
            raw "}"
        else
            start += ";"
            raw start
        end
    end

end

module Nova::Helper
    include Nova::Helper::ObjCDSL
end
